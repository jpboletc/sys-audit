"""Report generation for audit results."""

import json
from datetime import datetime
from typing import Any

from sys_audit.db.models import Audit, Finding, Severity


class ReportGenerator:
    """Generates reports from audit results in various formats."""

    def generate(
        self,
        audit: Audit,
        format: str = "markdown",
        stakeholder: str | None = None,
    ) -> str:
        """Generate a report from audit results.

        Args:
            audit: The audit to generate a report for
            format: Output format (markdown, html, json)
            stakeholder: Filter findings for a specific stakeholder

        Returns:
            The generated report as a string
        """
        # Filter findings by stakeholder if specified
        findings = list(audit.findings)
        if stakeholder:
            findings = [
                f for f in findings
                if stakeholder.lower() in [s.lower() for s in f.stakeholders]
            ]

        if format == "markdown":
            return self._generate_markdown(audit, findings)
        elif format == "html":
            return self._generate_html(audit, findings)
        elif format == "json":
            return self._generate_json(audit, findings)
        else:
            raise ValueError(f"Unknown format: {format}")

    def _generate_markdown(self, audit: Audit, findings: list[Finding]) -> str:
        """Generate a markdown report."""
        lines = [
            f"# Audit Report: {audit.project.name}",
            "",
            f"**Audit ID:** `{audit.id}`",
            f"**Date:** {audit.completed_at.strftime('%Y-%m-%d %H:%M') if audit.completed_at else 'N/A'}",
            f"**Status:** {audit.status.value}",
            "",
        ]

        # Summary
        lines.extend([
            "## Summary",
            "",
            f"Total findings: **{len(findings)}**",
            "",
        ])

        # Findings by severity
        by_severity = self._group_by_severity(findings)
        if by_severity:
            lines.append("### By Severity")
            lines.append("")
            for severity in [Severity.CRITICAL, Severity.HIGH, Severity.MEDIUM, Severity.LOW, Severity.INFO]:
                count = len(by_severity.get(severity, []))
                if count > 0:
                    emoji = self._severity_emoji(severity)
                    lines.append(f"- {emoji} **{severity.value.title()}**: {count}")
            lines.append("")

        # Findings by skill
        by_skill = self._group_by_skill(findings)
        if by_skill:
            lines.append("### By Skill")
            lines.append("")
            for skill_name, skill_findings in sorted(by_skill.items()):
                lines.append(f"- **{skill_name}**: {len(skill_findings)}")
            lines.append("")

        # Detailed findings
        lines.extend([
            "## Findings",
            "",
        ])

        # Group by severity for output
        for severity in [Severity.CRITICAL, Severity.HIGH, Severity.MEDIUM, Severity.LOW, Severity.INFO]:
            severity_findings = by_severity.get(severity, [])
            if not severity_findings:
                continue

            emoji = self._severity_emoji(severity)
            lines.append(f"### {emoji} {severity.value.title()} ({len(severity_findings)})")
            lines.append("")

            for finding in severity_findings:
                lines.extend(self._format_finding_markdown(finding))
                lines.append("")

        # Footer
        lines.extend([
            "---",
            "",
            f"*Generated by sys-audit v0.1.0 at {datetime.now().strftime('%Y-%m-%d %H:%M')}*",
        ])

        return "\n".join(lines)

    def _format_finding_markdown(self, finding: Finding) -> list[str]:
        """Format a single finding as markdown."""
        lines = [
            f"#### {finding.title}",
            "",
        ]

        if finding.file_path:
            location = finding.file_path
            if finding.line_start:
                location += f":{finding.line_start}"
                if finding.line_end and finding.line_end != finding.line_start:
                    location += f"-{finding.line_end}"
            lines.append(f"**Location:** `{location}`")

        lines.append(f"**Skill:** {finding.skill_name}")
        lines.append(f"**Category:** {finding.category}")
        lines.append(f"**Confidence:** {finding.confidence:.0%}")

        if finding.effort_estimate:
            lines.append(f"**Effort:** {finding.effort_estimate.value}")

        lines.append("")

        if finding.description:
            lines.append(finding.description)
            lines.append("")

        if finding.code_snippet:
            lines.append("```")
            lines.append(finding.code_snippet)
            lines.append("```")
            lines.append("")

        if finding.recommendation:
            lines.append(f"**Recommendation:** {finding.recommendation}")

        return lines

    def _generate_html(self, audit: Audit, findings: list[Finding]) -> str:
        """Generate an HTML report."""
        # For now, wrap markdown in basic HTML
        markdown = self._generate_markdown(audit, findings)
        return f"""<!DOCTYPE html>
<html>
<head>
    <title>Audit Report: {audit.project.name}</title>
    <style>
        body {{ font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif; max-width: 900px; margin: 0 auto; padding: 20px; }}
        pre {{ background: #f5f5f5; padding: 10px; overflow-x: auto; }}
        code {{ background: #f5f5f5; padding: 2px 4px; }}
        h1 {{ border-bottom: 2px solid #333; }}
        h2 {{ border-bottom: 1px solid #ccc; }}
        h4 {{ margin-bottom: 0.5em; }}
    </style>
</head>
<body>
<pre style="white-space: pre-wrap; font-family: inherit; background: none;">
{markdown}
</pre>
</body>
</html>"""

    def _generate_json(self, audit: Audit, findings: list[Finding]) -> str:
        """Generate a JSON report."""
        data: dict[str, Any] = {
            "audit_id": audit.id,
            "project": audit.project.name,
            "status": audit.status.value,
            "completed_at": audit.completed_at.isoformat() if audit.completed_at else None,
            "summary": {
                "total_findings": len(findings),
                "by_severity": {
                    sev.value: len([f for f in findings if f.severity == sev])
                    for sev in Severity
                },
            },
            "findings": [
                {
                    "id": f.id,
                    "skill_name": f.skill_name,
                    "severity": f.severity.value if hasattr(f.severity, "value") else f.severity,
                    "category": f.category,
                    "title": f.title,
                    "description": f.description,
                    "file_path": f.file_path,
                    "line_start": f.line_start,
                    "line_end": f.line_end,
                    "recommendation": f.recommendation,
                    "effort_estimate": f.effort_estimate.value if f.effort_estimate else None,
                    "confidence": f.confidence,
                    "source": f.source.value if hasattr(f.source, "value") else f.source,
                }
                for f in findings
            ],
        }
        return json.dumps(data, indent=2)

    def _group_by_severity(self, findings: list[Finding]) -> dict[Severity, list[Finding]]:
        """Group findings by severity."""
        grouped: dict[Severity, list[Finding]] = {}
        for finding in findings:
            severity = finding.severity
            if isinstance(severity, str):
                severity = Severity(severity)
            if severity not in grouped:
                grouped[severity] = []
            grouped[severity].append(finding)
        return grouped

    def _group_by_skill(self, findings: list[Finding]) -> dict[str, list[Finding]]:
        """Group findings by skill name."""
        grouped: dict[str, list[Finding]] = {}
        for finding in findings:
            if finding.skill_name not in grouped:
                grouped[finding.skill_name] = []
            grouped[finding.skill_name].append(finding)
        return grouped

    def _severity_emoji(self, severity: Severity) -> str:
        """Get emoji for severity level."""
        return {
            Severity.CRITICAL: "ðŸ”´",
            Severity.HIGH: "ðŸŸ ",
            Severity.MEDIUM: "ðŸŸ¡",
            Severity.LOW: "ðŸ”µ",
            Severity.INFO: "âšª",
        }.get(severity, "âšª")
